# -*- coding: utf-8 -*-
##############################################################################
#
#    OpenERP, Open Source Management Solution
#    Copyright (C) 2012-now Gnuthink Software Labs Co. Ltd. (<http://www.gnuthink.com>).
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

from time import strftime, strptime
from osv import osv, fields
from gt_tool import tool
from datetime import date, datetime

class hr_novedad(osv.osv):
    _name = 'hr.novedad'
    
    _columns = {
                'name': fields.selection([('funcion_judicial','Funcion Judicial'),
                                          ('pension_alimentos','Pension de alimentos')],'Descripcion', required=True),
                'family_id': fields.many2one('hr.family.item', 'Familiar', required=True),
                #'type': fields.many2one('hr.salary.rule.category', 'Categoria salarial'),
                'value': fields.float('Valor', required=True),
                }
    
hr_novedad()

## #PROJECTION LINE

class hrAnualProjection(osv.osv):
    _name = 'hr.anual.projection'
    _description='Proyeccion Anual'

    def _compute_all(self, cr, uid, id, name, args, context):
        sum=0
        result={}
        for anual in self.browse(cr, uid, id):
            for line in anual.line_ids:
                sum+=line.value
            result[anual.id]=sum
        return result

    _columns = dict(
                    name = fields.char('Descripción',size=128),
                    fy_id = fields.many2one('hr.work.period','Año Laboral'),
                    total = fields.function(_compute_all, method=True, string='Total', type='float'),
                    line_ids = fields.one2many('hr.projection.line','pl_id','Lineas Proyección'),
                    employee_id = fields.many2one('hr.employee','Empleado'),
                    )

hrAnualProjection()

class hrContractProjection(osv.osv):

    _name = 'hr.contract.projection'
    _descripcion = "Proyecciones Imp. a la Renta"
    
    _columns = dict(
        code = fields.char('Código',size=8),
        name = fields.char('Nombre',  size=32),
        description = fields.text('Descripción'),
        )

hrContractProjection()

class hrProjectionLine(osv.osv):
    
    _name='hr.projection.line'
    _columns = dict(
        #name = fields.char('Desc.',size=8),
        projection_id = fields.many2one('hr.deduction','Deducción'),
        value = fields.float('Valor'),
        pl_id = fields.many2one('hr.anual.projection', 'Año'),
        )

hrProjectionLine()

class hrAnualRentTax(osv.osv):
    _name='hr.anual.rent.tax'

    _columns = dict(
        name = fields.char('Descripción',size=128),
        fy_id = fields.many2one('hr.work.period','Año Laboral'),
        #start_computed = fields.float('A pagar inicial anual'),
        #mensual = fields.float('Mensual Aprox.'),
        #end_computed = fields.float('Pagado anual real'),    
        line_ids = fields.one2many('hr.rent.tax','tl_id','Impuesto Renta'),
        employee_id = fields.many2one('hr.employee','Empleado'),
        )
    
hrAnualRentTax()

class hrRentTax(osv.osv):
    _name = 'hr.rent.tax'
    _columns = dict(
        #name = fields.char('Descripcion',size=32),
        period_id = fields.many2one('hr.work.period.line','Periodo'),
        apt_proy = fields.float('Aportables y proyectables'),
        apt_noproy = fields.float('Aportables no proyectables'),
        noapt_proy = fields.float('No aportable proyectable'),
        noapt_noproy = fields.float('No aportable no proyectable'),
        valor = fields.float('Valor retenido'),
        tl_id = fields.many2one('hr.anual.rent.tax','Año'),
        )
    
    _defaults = {
                 'apt_proy': 0,
                 'apt_noproy': 0,
                 'noapt_proy': 0,
                 'noapt_noproy': 0,
                 'valor': 0,
                 }
hrRentTax()

class hrFamilyItem(osv.osv):
    _name = 'hr.family.item'
    _description = 'Cargas/Miembros de la familia'
    _order = 'name desc'
    

    def onchange_birth(self, cr, uid, ids, birth):
        v={}
        result={}
        if birth:
            fecha_n = datetime.strptime(birth, "%Y-%m-%d")
            if fecha_n <= datetime.today():
                today = datetime.today().strftime("%Y-%m-%d")
                now = today.split('-')
                birth = birth.split('-')
                datenow = date( int(now[0]), int(now[1]), int(now[2]) )
                datebirth = date( int(birth[0]), int(birth[1]), int(birth[2]) )
                delta = datenow - datebirth
                age = delta.days/365
                v['age']=int(age)
                return {'value' : v}
            else:
                result['value']={'birth':""}
                result['warning']={'title' : 'Error de Usuario', 
                                   'message':'La fecha de nacimiento no puede ser mayor a la actual'}
        return result
    
    _RELATION = [('hb_wife','Esposo (a)'), ('son', 'Hijo (a)'),
                 ('padre','Padre'),('madre','Madre'),
                 ('tio','Tio'),('hermano','Hermano'),
                 ('sobrino','Sobrino'),('ulibre','Unión Libre'),
                 ('entenado','Otro')]
            
    _columns = dict(
        name = fields.char('Nombre Completo', size=50, required=True),
        sex = fields.selection([('h','Hombre'),('m','Mujer')],'Sexo'),
        #age = fields.integer('Edad'),
        carga_justificada = fields.boolean('Es una carga justificada?', help="Activar esta casilla si la carga familiar se encuentra justificada"),
        birth = fields.date('Fecha de Nacimiento'),
        relationship = fields.selection(_RELATION,'Parentezco'),
        disabled = fields.boolean('Discapacitado?', help="Marque este campo si la carga familiar es discapacitado, tenga en cuenta que un carga faliliar que sea mayor de edad pero con discapacidad se toma en cuenta para el cálculo de utilidades"),
        employee_id =  fields.many2one('hr.employee', 'Empleado'),
        #novedad_ids = fields.one2many('hr.novedad', 'family_id', 'Rubros Fijos'),
        recibe_pension = fields.selection([('pension_alimentos','Pension de Alimentos'),('funcion_judicial','Funcion Judicial')],'Recibe pension?', help='Activar este campo en caso que esta carga familiar reciba una pension de alimentos, y elija el tipo de descuento'),
        valor_pension = fields.float('Valor',help='Valor a cobrar por la pension'),
        cuenta_pension = fields.many2one('res.partner.bank','Cuenta Bancaria', help='Cuenta bancaria en la cual se debe realizar el deposito por la pension')
        )
    
    _defaults = dict(
        #age = 0,
        )
    
hrFamilyItem()

class hrEmployeeCourse(osv.osv):
    _name = 'hr.employee.course'
    _description = 'Cursos Empleado'
    _MODALITY = [('v','Virtual'),('d','Distancia'),('p','Presencial'),
                 ('s','Semipresencial'),('o','Otros')]
    _columns = dict(
        name = fields.char('Tema',size=128,required=True),
        hours =  fields.integer('Numero de horas'),
        modality = fields.selection(_MODALITY,'Modalidad'),
        institute = fields.char('Institucion',size=32),
        employee_id = fields.many2one('hr.employee', 'Empleado'),
        tipo = fields.selection([('aprobacion','de aprobacion'),('asistencia','de asistencia')],'Tipo de Curso'),
        )
hrEmployeeCourse()

class title(osv.osv):
    _name = 'title'
    _description = 'Titulos Academicos'
    _order = 'name desc'
    _columns = dict(
        name = fields.char('Título', size=32),
        )
title()

class hrEmployeeTitle(osv.osv):   
    _name= 'hr.employee.title'
    _description = 'Titulos Empleado'
    _order = 'name desc,nivel desc'
    _LEVEL = [('art','Artesano'),('bas','Básica'),('bach','Bachillerato'),
              ('sup','Superior Técnico'),('egr','Egresado'),
              ('tercer','Tercer Nivel'),('cuarto','Cuarto Nivel')]
    _columns = dict(
        name = fields.many2one('title','Título',required="1"),
        institute = fields.char('Universidad', size=128),
        nivel = fields.selection(_LEVEL,'Nivel'),
        codigo = fields.char('Codigo SENESCYT', size=50),
        employee_id = fields.many2one('hr.employee', 'Empleado'),
        )
    
hrEmployeeTitle()

class hrEmployeeType(osv.osv):
    _name = 'employee.type'
    _columns = dict(
        name = fields.char('Tipo', size = 16)
        )
hrEmployeeType()

class hr_marital_status(osv.osv):
    _name = 'hr.marital.status'
    _columns = dict(
        name = fields.char('Estado Civil', size = 20)
        )
hr_marital_status()

class resource_resource_order(osv.osv):
    _inherit = 'resource.resource'
    _order = 'name asc'
    
    _defaults = {
                 'name': '0',
                 }
resource_resource_order()

class hrEmployee(osv.osv):
    _inherit = 'hr.employee'
    _order = 'complete_name asc'
    
    _TIPOID = [('c','Cedula'),('p','Pasaporte')]
    _BLOOD = [('on','O-'),('op','O+'),('an','A-'),('ap','A+'),
              ('bn','B-'),('bp','B+'),('abn','AB-'),('abp','AB+')]
    
    def limpiar_puesto(self, cr, uid, ids, context={}):
        return {'value':{'job_id': False}}
    
    def _get_latest_contract(self, cr, uid, ids, field_name, args, context=None):
        #PROCESO REDEFINIDO DEL MODULO HR.CONTRACT
        res = {}
        obj_contract = self.pool.get('hr.contract')
        for emp in self.browse(cr, uid, ids, context=context):
            contract_ids = obj_contract.search(cr, uid, [('employee_id','=',emp.id),('active','=',True)], order='date_start', context=context)
            if contract_ids:
                res[emp.id] = contract_ids[-1:][0]
            else:
                res[emp.id] = False
        return res

    def _compute_age(self, cr, uid, ids, field_name, arg, context):
        v={}
        result = {}
        for this in self.browse(cr, uid, ids):
            result[this.id] = ""
            birth=this.birthday
            if birth:
                fecha_n = datetime.strptime(birth, "%Y-%m-%d")
                if fecha_n <= datetime.today():
                    today = datetime.today().strftime("%Y-%m-%d")
                    now = today.split('-')
                    birth = birth.split('-')
                    datenow = date( int(now[0]), int(now[1]), int(now[2]) )
                    datebirth = date( int(birth[0]), int(birth[1]), int(birth[2]) )
                    delta = datenow - datebirth
                    age = delta.days/365
                    result[this.id] = age
        return result

    def _compute_hijos18(self, cr, uid, ids, field_name, arg, context):
        for employee in self.browse(cr, uid, ids):
            aux = 0
            for family in employee.family_item_ids:
                if family.age<=18 or family.disabled:
                    aux += 1
        return {employee.id:aux}
    
    def onchange_provincia(self, cr, uid, ids, context={}):
        return {'value':{'canton_id':False,
                         'parish_id':False}}
        
    def onchange_canton(self, cr, uid, ids, context={}):
        return {'value':{'parish_id':False}}
    
    def _complete_name(self, cr, uid, ids, field_name, arg, context):
        res = {}
        for employee in self.browse(cr, uid, ids):
            name = ""
            if employee.employee_first_lastname:
                name = name + employee.employee_first_lastname
            if employee.employee_second_lastname:
                name = name + " " + employee.employee_second_lastname
            if employee.employee_first_name:
                name = name + " " + employee.employee_first_name
            if employee.employee_second_name:
                name = name + " " + employee.employee_second_name
            res[employee.id] = name
        return res
    
    def name_get(self, cr, uid, ids, context=None):
        if context is None:
            context = {}
        if not ids:
            return []
        res = []
        reads = self.browse(cr, uid, ids, context=context)
        for record in reads:
            name = ""
            #if record.employee_first_lastname:
            #    name = name + record.employee_first_lastname
            #if record.employee_second_lastname:
            #    name = name + " " + record.employee_second_lastname
            #if record.employee_first_name:
            #    name = name + " " + record.employee_first_name
            #if record.employee_second_name:
            #    name = name + " " + record.employee_second_name
            if record.complete_name:
                name = record.complete_name
            res.append((record.id, name))
        return res
    
    def name_search(self, cr, uid, name='', args=[], operator='ilike', context={}, limit=80):
        ids = []
        ids_cedula = self.search(cr, uid, [('name', operator, name)] + args, limit=limit, context=context)
        ids = list(set(ids + ids_cedula))
        if name:
            #ids_first_lastname = self.search(cr, uid, [('employee_first_lastname', operator, name)] + args, limit=limit, context=context)
            #ids_second_lastname = self.search(cr, uid, [('employee_second_lastname', operator, name)] + args, limit=limit, context=context)
            #ids_first_name = self.search(cr, uid, [('employee_first_name', operator, name)] + args, limit=limit, context=context)
            #ids_second_name = self.search(cr, uid, [('employee_second_name', operator, name)] + args, limit=limit, context=context)
            #ids = list(set(ids + ids_first_lastname))
            #ids = list(set(ids + ids_second_lastname))
            #ids = list(set(ids + ids_first_name))
            #ids = list(set(ids + ids_second_name))
            ids_name = self.search(cr, uid, [('complete_name', operator, name)] + args, limit=limit, context=context)
            ids = list(set(ids + ids_name))
        return self.name_get(cr, uid, ids, context=context)
    
    

    def _check_identificador(self, cr, uid, ids):
        for employee in self.browse(cr, uid, ids):
            if employee.id_type=='c':
                return tool._check_cedula(employee.name)
            else:
                return True

    _columns = dict(
        complete_name = fields.function(_complete_name, method=True, string="Nombre Completo", store=True, type="char", size=120), 
        #employee_name = fields.char('Nombres', size=50, required=True),
        name = fields.char('ID', size=10, help="Es el numero de identificador, debe ser único", required=True),
        employee_first_name = fields.char('Primer Nombre', size=30),
        employee_second_name = fields.char('Segundo Nombre', size=30),
        employee_first_lastname = fields.char('Primer Apellido', size=30),
        employee_second_lastname = fields.char('Segundo Apellido', size=30),
        #place_birth = fields.char('Lugar de nacimiento',size=32),
        personal_mail = fields.char('Mail Personal',size=32),
        #ci = fields.char('ID', size=10, help="Es el numero de identificador, debe ser único", required=True),
        id_type = fields.selection(_TIPOID, "Tipo ID",
                                     help="Es el tipo de identificador"),
        family_item_ids = fields.one2many('hr.family.item', 'employee_id', "Items Familia"),
        #children_18 =  fields.function(_compute_hijos18, method=True, string="Cargas Para Utilidad", 
        #                               store=True, type="integer"), 
        #type_id = fields.many2one('employee.type','Tipo',required=True),
        academic_ids = fields.one2many('hr.employee.title','employee_id','Datos Titulos'),
        course_ids  = fields.one2many('hr.employee.course','employee_id','Datos Cursos'),
        #experience_ids  = fields.one2many('hr.employee.course','employee_id','Datos Cursos'),
        #age = fields.function(_compute_age, method=True, string="Edad", store=True, type="integer"),
        country_id =  fields.many2one('res.country', 'Pais'),
        state_id = fields.many2one('res.country.state','Provincia'),
        canton_id = fields.many2one('res.country.state.canton','Canton'),
        parish_id = fields.many2one('res.country.state.parish','Parroquia'),
        #city = fields.many2one('res.country.state.city','Ciudad'),
        discapacitado = fields.boolean('Discapacitado',help="Marque este campo, si el empleado tiene alguna limitación para llevar a cabo ciertas actividades provocadas por una deficiencia física o mental"),
        tipo_discapacidad = fields.char('Tipo Discapacidad',size=64),
        porcentaje_discapacidad = fields.float('Porcentaje Discapacidad',size=64),
        id_conadis = fields.char('ID CONADIS',size=10,help="Codigo de identificación del CONADIS"),
        blood_type =  fields.selection(_BLOOD,'Tipo Sangre'),
        address = fields.char('Direccion',size=256),
        #house_number = fields.char('Num. de Casa', size=5),
        house_phone = fields.char('Telefono Convencional', size=15),
        marital_id = fields.many2one('hr.marital.status', 'Estado Civil'),
        email = fields.char('Email Personal', size=240),
        #ocupational_id = fields.many2one('grupo.ocupacional', 'Grupo Ocupacional'),
        contacto_emergencia = fields.char('En caso de emergencia llamar a', size=50, help="Indique el nombre y la relacion del empleado con este contacto de emergencia"),
        numero_emergencia = fields.char('Telefono del contacto', size=30),
        ppi = fields.integer('PPI'),
        receives_notifications = fields.boolean('Recibe notificaciones?', help="Activar el casillero si el empleado recibe notificaciones por correo electrónico"),
        #sup_id = fields.many2one('res.partner','Empresa Relacionada',required=True),
        #partner_id = fields.many2one('res.partner','Empresa Relacionada',required=True),
        state_system = fields.boolean('Presente'),
        projection_ids = fields.one2many('hr.anual.projection','employee_id','Proyecciones'),
        rent_tax_ids = fields.one2many('hr.anual.rent.tax','employee_id','Impuesto Renta'),
        )

    _constraints = [
        (_check_identificador,'El identificador es invalido, por favor verifique',['name']),
        ]

    _sql_constraints = [
        ('unique_cedula_emp','unique(name,id_type)','Solo puede tener un mismo numero de identificador por empleado.')
        ]
    
    _defaults = dict(
        #children_18 = 0,
        id_type = 'c',
        name = '0',
        active = True,
        blood_type = 'op',
        state_system = False,
        )

hrEmployee()

class resBankAccount(osv.osv):
    _inherit = 'res.partner.bank'
    _TIPO = [('aho','Cta. Ahorros'),('cte','Cta. Corriente'),
             ('vir','Cta. Virtual')]
    _columns = {
        'type_cta': fields.selection(_TIPO , 'Tipo de cuenta', required=True),
        'bank': fields.many2one('res.bank', 'Bank', required=True),
        }
    
    _defaults = dict(
        type_cta = 'aho',
        )
resBankAccount()
